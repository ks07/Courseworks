Q.1 Imagine that instead of influencing data (i.e., the state matrix), a
    fault can influence control-flow (e.g., conditional statements, loop
    structure) somehow during execution.  Stating any assumptions you make,
    give an alternative attack strategy based on this ability.

    Assume that a fault can be induced in the final round (10) of AES-128 encryption, skipping execution of the entirety of a single operation in the round. The simplest resulting attack is that where the final AddRoundKey operation is skipped, producing an output of the encryption algorithm of C* = ShiftRows(SubBytes(S_9)), where S_9 is the state matrix at the end of round 9. Considering that the correct output, C, is ShiftRows(SubBytes(S_9)) xor K_10, where K_10 is the final round key. The AES-128 KeySchedule algorithm is invertible with a single round key, thus by obtaining K_10 = C* xor C, we can obtain the original key.

    Depending on the implementation of the target under attack (likewise, any countermeasures that may be present), it may be prohibitively difficult to skip the final AddRoundKey operation. Alternative attacks are possible, attacking the other operations of AES encryption. If the SubBytes operation is skipped entirely, the difference between the correct and faulty ciphertexts can be used to greatly reduce the set of possible values for K_10. In the worst case, the search space is 2 bits per key byte, i.e. 32 bits. This space is small enough to tackle with exhaustive search. A perhaps more realisitic attack, using the same principles, is possible upon implementations with shared encryption/decryption datapaths. If an attacker is able to invert the conditional branch that selects between SubBytes and InverseSubBytes, the difference between the output correct and incorrect ciphertexts can be used in the same manner to produce a reduced search space that can be exhaustively searched (albeit with a slightly larger worst-case search space). Skipping the ShiftRows operation, and comparing with the correct ciphertext, results in the ability to narrow the number of possibilities for the temporary state s after the ShiftRows step (and thus a reduced search space for the round key, K_10 = s xor C). As the ShiftRows step does not modify the first row of the state matrix, no information can be gained about this first row, so the search space is somewhat larger than that for the SubBytes attack (to a total of 64 bits). Finally, as a slight divergence to the previous 3 attacks, an attacker may also be able to invoke the MixColumns operation in the final round. This results in a similar reduced space exhaustive search of 32 bits.

Q.2 The question does not specify how faults are induced.  For the given
    attack target and context, explain one viable approach.

    Faults can be induced in a device in a number of ways, including increasing clock frequency above data and control path tolerances, increasing or decreasing supply voltage (both generally in short spikes to control their effects), applying optical light (from a laser or other suitable high intensity light source, and the photoelectric effect. See the recent news about the Raspberry Pi and xenon flash causing reboots for a more benign example), amongst others.

    One viable approach for inducing a fault in the processor powering the smart-card we are attacking would be that of clock glitching. This consists of a momentary sudden increase in clock frequency, that can cause a microprocessor to perform a single instruction incorrectly, returning to normal execution afterwards. Exceeding the maximum possible clock frequency means that the clock signal may not propagate to all components in the processor before the next clock cycle begins. This means that data or control signals travelling through their respective paths might be lost before they can reach their intended destination (e.g. by a register being activated for write before the input data has been correctly driven on the input). A common intended effect of this type of glitch is that of skipping a single instruction entirely.

    This attack could be implemented using an FPGA, or a microcontroller running at a suitably high clock frequency. The clock input to the smart-card could be controlled by this microcontroller. Through some calibration steps (experimentally investigating the effects of the glitch at different times), or by using some knowledge of the AES implementation, we can find when to inject the glitch in the clock input. At this time, we use the microcontroller to briefly boost the clock frequency above the tolerance of the target device for one of it's clock cycles (or longer, depending on the architecture and target instruction(s)). The clock signal will not have time to propagate throughout the target device, causing a fault in that instruction, pottentially skipping it entirely.

Q.3 For side-channel attacks, the number of acquisitions required can be
    used as a measure of efficiency.  Outline the equivalent measure for
    fault attacks, and explain whether (and why) you think a side-channel
    attack on AES could be as efficient as a fault attack based on these
    measures.


Q.4 How do the properties of different AES round functions influence the
    effectiveness of your attack?  More specifically, imagine SubBytes is
    removed: does this help or hinder your attack?
