Q.1 Imagine that instead of influencing data (i.e., the state matrix), a
    fault can influence control-flow (e.g., conditional statements, loop
    structure) somehow during execution.  Stating any assumptions you make,
    give an alternative attack strategy based on this ability.

    Assume that a fault can be induced in the final round (10) of AES-128 encryption, skipping execution of the entirety of a single operation in the round. The simplest resulting attack is that where the final AddRoundKey operation is skipped, producing an output of the encryption algorithm of C* = ShiftRows(SubBytes(S_9)), where S_9 is the state matrix at the end of round 9. Considering that the correct output, C, is ShiftRows(SubBytes(S_9)) xor K_10, where K_10 is the final round key. The AES-128 KeySchedule algorithm is invertible with a single round key, thus by obtaining K_10 = C* xor C, we can obtain the original key.

    Depending on the implementation of the target under attack (likewise, any countermeasures that may be present), it may be prohibitively difficult to skip the final AddRoundKey operation. Alternative attacks are possible, attacking the other operations of AES encryption. If the SubBytes operation is skipped entirely, the difference between the correct and faulty ciphertexts can be used to greatly reduce the set of possible values for K_10. In the worst case, the search space is 2 bits per key byte, i.e. 32 bits. This space is small enough to tackle with exhaustive search. A perhaps more realisitic attack, using the same principles, is possible upon implementations with shared encryption/decryption datapaths. If an attacker is able to invert the conditional branch that selects between SubBytes and InverseSubBytes, the difference between the output correct and incorrect ciphertexts can be used in the same manner to produce a reduced search space that can be exhaustively searched (albeit with a slightly larger worst-case search space). Skipping the ShiftRows operation, and comparing with the correct ciphertext, results in the ability to narrow the number of possibilities for the temporary state s after the ShiftRows step (and thus a reduced search space for the round key, K_10 = s xor C). As the ShiftRows step does not modify the first row of the state matrix, no information can be gained about this first row, so the search space is somewhat larger than that for the SubBytes attack (to a total of 64 bits). Finally, as a slight divergence to the previous 3 attacks, an attacker may also be able to invoke the MixColumns operation in the final round. This results in a similar reduced space exhaustive search of 32 bits.

Q.2 The question does not specify how faults are induced.  For the given
    attack target and context, explain one viable approach.

    Faults can be induced in a device in a number of ways, including increasing clock frequency above data and control path tolerances, increasing or decreasing supply voltage (both generally in short spikes to control their effects), applying optical light (from a laser or other suitable high intensity light source, and the photoelectric effect. See the recent news about the Raspberry Pi and xenon flash causing reboots for a more benign example), amongst others.

    One viable approach for inducing a fault in the processor powering the smart-card we are attacking would be that of clock glitching. This consists of a momentary sudden increase in clock frequency, that can cause a microprocessor to perform a single instruction incorrectly, returning to normal execution afterwards. Exceeding the maximum possible clock frequency means that the clock signal may not propagate to all components in the processor before the next clock cycle begins. This means that data or control signals travelling through their respective paths might be lost before they can reach their intended destination (e.g. by a register being activated for write before the input data has been correctly driven on the input). A common intended effect of this type of glitch is that of skipping a single instruction entirely.

    This attack could be implemented using an FPGA, or a microcontroller running at a suitably high clock frequency. The clock input to the smart-card could be controlled by this microcontroller. Through some calibration steps (experimentally investigating the effects of the glitch at different times), or by using some knowledge of the AES implementation, we can find when to inject the glitch in the clock input. At this time, we use the microcontroller to briefly boost the clock frequency above the tolerance of the target device for one of it's clock cycles (or longer, depending on the architecture and target instruction(s)). The clock signal will not have time to propagate throughout the target device, causing a fault in that instruction, pottentially skipping it entirely.

Q.3 For side-channel attacks, the number of acquisitions required can be
    used as a measure of efficiency.  Outline the equivalent measure for
    fault attacks, and explain whether (and why) you think a side-channel
    attack on AES could be as efficient as a fault attack based on these
    measures.

    The equivalent measure for fault attacks is the number of faulty ciphertexts obtained (or the number of faults induced). I don't believe a side channel attack on AES could be as efficient as a fault attack when considering these metrics. This is because a side channel attack (whether it be time, power, or otherwise) requires a fairly large number of acquisitions in order to perform the statistical analysis required to make hypothesis on the key we are attempting to recover (e.g. to correlate power traces against the estimated power consumption for each key byte value, as in my DPA attack). A fault attack can be much more powerful, as a single fault can modify the output of the encryption process in such a way as to reveal an entire round key, for example.

Q.4 How do the properties of different AES round functions influence the
    effectiveness of your attack?  More specifically, imagine SubBytes is
    removed: does this help or hinder your attack?

    AES uses an S-P network, where the Substitution and Permutation steps of the algorithm account for confusion and diffusion, respectively. The SubBytes operation, performing substitution/confusion, prevents AES from being a linear operation. Removing the SubBytes would make my attack easier. With the removal of the SubBytes operation, a linear system of equations could be devised relating each input byte to each byte of the ciphertext. This would make retrieving the key much easier, as exhaustive searches could be restricted to only considering single bytes at a time instead of the entire key. This would greatly reduce the total number of possibilities to be tested.
